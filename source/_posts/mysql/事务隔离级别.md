---
title: 事务隔离级别
date: 2016-07-23 21:20:52
tags: [mysql, 事务]
---
# 未提交读(Read uncommitted)
未提交读(READ UNCOMMITTED)是最低的隔离级别。通过名字我们就可以知道，在这种事务隔离级别下，一个事务可以读到另外一个事务未提交的数据。

## 未提交读的数据库锁情况
* 事务在读数据的时候并未对数据加锁。
* 事务在修改数据的时候只对数据增加行级共享锁。

## 现象
事务1读取某行记录时，事务2也能对这行记录进行读取、更新（因为事务一并未对数据增加任何锁）
当事务2对该记录进行更新时，事务1再次读取该记录，能读到事务2对该记录的修改版本（因为事务二只增加了共享读锁，事务一可以再增加共享读锁读取数据），即使该修改尚未被提交。
事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。（因为事务一对数据增加了共享读锁，事务二不能增加排他写锁进行数据的修改）

## 举例

| 事务一                              | 事务二                                  |
| ----------------------------------- | --------------------------------------- |
|                                     | UPDATE users SET age = 21 WHERE id = 1; |
| SELECT age FROM users WHERE id = 1; |                                         |
|                                     | ROLLBACK;                               |

事务一共查询了两次，在两次查询的过程中，事务二对数据进行了修改，并未提交（commit）。但是事务一的第二次查询查到了事务二的修改结果。在数据库的读现象浅析中我们介绍过，这种现象我们称之为[脏读](/2016/07/24/mysql/数据库中的读现象/#脏读-一个事务读取到了另外一个事务没有提交的数据)。

所以，未提交读会导致[脏读](/2016/07/24/mysql/数据库中的读现象/#脏读-一个事务读取到了另外一个事务没有提交的数据)

# 提交读(Read committed)
提交读(READ COMMITTED)也可以翻译成读已提交，通过名字也可以分析出，在一个事务修改数据过程中，如果事务还没提交，其他事务不能读该数据。

## 提交读的数据库锁情况
* 事务对当前被读取的数据加 行级共享锁（当读到时才加锁），一旦读完该行，立即释放该行级共享锁；
* 事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。

## 现象
事务1在读取某行记录的整个过程中，事务2都可以对该行记录进行读取（因为事务一对该行记录增加行级共享锁的情况下，事务二同样可以对该数据增加共享锁来读数据）。
事务1读取某行的一瞬间，事务2不能修改该行数据，但是，只要事务1读取完改行数据，事务2就可以对该行数据进行修改。（事务一在读取的一瞬间会对数据增加共享锁，任何其他事务都不能对该行数据增加排他锁。但是事务一只要读完该行数据，就会释放行级共享锁，一旦锁释放，事务二就可以对数据增加排他锁并修改数据）
事务1更新某行记录时，事务2不能对这行记录做更新，(直到事务1结束。事务一在更新数据的时候，会对该行数据增加排他锁，直到事务结束才会释放锁，所以，在事务一没有提交之前，事务二都能不对数据增加共享锁进行数据的读取。所以，提交读可以解决***脏读***的现象)

## 举例

| 事务一                                      | 事务二                                          |
| ------------------------------------------- | ----------------------------------------------- |
| SELECT age FROM users WHERE id = 1;         |                                                 |
|                                             | UPDATE users SET age = 21 WHERE id = 1; COMMIT; |
| SELECT age FROM users WHERE id = 1; COMMIT; |                                                 |

在提交读隔离级别中，在事务二提交之前，事务一不能读取数据。只有在事务二提交之后，事务一才能读数据。

# 可重复读(Repeatable reads)
可重复读(REPEATABLE READS),由于提交读隔离级别会产生不可重复读的读现象。所以，比提交读更高一个级别的隔离级别就可以解决不可重复读的问题。这种隔离级别就叫可重复读

## 可重复读的数据库锁情况
* 事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加 行级共享锁，直到事务结束才释放；
* 事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。

## 现象
事务1在读取某行记录的整个过程中，事务2都可以对该行记录进行读取（因为事务一对该行记录增加行级共享锁的情况下，事务二同样可以对该数据增加共享锁来读数据。）。
事务1在读取某行记录的整个过程中，事务2都不能修改该行数据（事务一在读取的整个过程会对数据增加共享锁，直到事务提交才会释放锁，所以整个过程中，任何其他事务都不能对该行数据增加排他锁。所以，可重复读能够解决不可重复读的读现象）
事务1更新某行记录时，事务2不能对这行记录做更新，(直到事务1结束。事务一在更新数据的时候，会对该行数据增加排他锁，直到事务结束才会释放锁，所以，在事务一没有提交之前，事务二都能不对数据增加共享锁进行数据的读取。所以，提交读可以解决***脏读***的现象)

## 举例

| 事务一                                      | 事务二                                          |
| ------------------------------------------- | ----------------------------------------------- |
| SELECT age FROM users WHERE id = 1; COMMIT; |                                                 |
|                                             | UPDATE users SET age = 21 WHERE id = 1; COMMIT; |
在上面的例子中，只有在事务一提交之后，事务二才能更改该行数据。所以，只要在事务一从开始到结束的这段时间内，无论他读取该行数据多少次，结果都是一样的。

从上面的例子中我们可以得到结论：可重复读隔离级别可以解决不可重复读的读现象。但是可重复读这种隔离级别中，还有另外一种读现象他解决不了，那就是幻读。看下面的例子：

| 事务一                                           | 事务二                                              |
| ------------------------------------------------ | --------------------------------------------------- |
| SELECT * FROM users WHERE age BETWEEN 10 AND 30; |                                                     |
|                                                  | INSERT INTO users VALUES ( 3, 'Bob', 27  ); COMMIT; |
| SELECT * FROM users WHERE age BETWEEN 10 AND 30; |                                                     |

上面的两个事务执行情况及现象如下：

1. 事务一的第一次查询条件是`age BETWEEN 10 AND 30;`如果这是有十条记录符合条件。这时，他会给符合条件的这十条记录增加行级共享锁。任何其他事务无法更改这十条记录。
2. 事务二执行一条sql语句，语句的内容是向表中插入一条数据。因为此时没有任何事务对表增加表级锁，所以，该操作可以顺利执行。
3. 事务一再次执行`SELECT * FROM users WHERE age BETWEEN 10 AND 30;`时，结果返回的记录变成了十一条，比刚刚增加了一条，增加的这条正是事务二刚刚插入的那条。

所以，事务一的两次范围查询结果并不相同。这也就是我们提到的幻读。

# 可序列化(Serializable)
可序列化(Serializable)是最高的隔离级别，前面提到的所有的隔离级别都无法解决的幻读，在可序列化的隔离级别中可以解决。
我们说过，产生幻读的原因是事务一在进行范围查询的时候没有增加范围锁(range-locks：给SELECT 的查询中使用一个“WHERE”子句描述范围加锁），所以导致幻读。)

## 可序列化的数据库锁情况
* 事务在读取数据时，必须先对其加 表级共享锁 ，直到事务结束才释放；
* 事务在更新数据时，必须先对其加 表级排他锁 ，直到事务结束才释放。

## 现象
事务1正在读取A表中的记录时，则事务2也能读取A表，但不能对A表做更新、新增、删除，直到事务1结束。(因为事务一对表增加了表级共享锁，其他事务只能增加共享锁读取数据，不能进行其他任何操作)
事务1正在更新A表中的记录时，则事务2不能读取A表的任意记录，更不可能对A表做更新、新增、删除，直到事务1结束。(事务一对表增加了表级排他锁，其他事务不能对表增加共享锁或排他锁，也就无法进行任何操作)
