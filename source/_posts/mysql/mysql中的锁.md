---
title: mysql中的锁
date: 2016-07-23 21:48:10
tags: [mysql, 锁]
---
# 锁的粒度
在DBMS中可以按照锁的粒度把数据库锁分为行级锁(InnoDB引擎)，表级锁(MyISAM引擎)和页级锁(BDB引擎)

## 行级锁
行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁和排他锁。

### 特点
* 开销大，加锁慢
* 会出现死锁
* 锁定粒度最小，发生锁冲突的概率最低，并发度也最高

## 表级锁
表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MyISAM与InnoDB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。

### 特点
* 开销小，加锁快
* 不会出现死锁
* 锁定粒度大，发出锁冲突的概率最高，并发度最低

## 页级锁
页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB支持页级锁
### 特点
* 开销和加锁时间界于表锁和行锁之间
* 会出现死锁
* 锁定粒度界于表锁和行锁之间，并发度一般

# MySQL常用存储引擎的锁机制
* MyISAM和MEMORY采用表级锁(table-level locking)
* BDB采用页面锁(page-level locking)或表级锁，默认为页面锁
* InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁

## InnoDB中的行锁与表锁
InnoDB行锁是通过给索引上的索引项加锁来实现的，InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！
行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。行级锁的缺点是：由于需要请求大量的锁资源，所以速度慢，内存消耗大。

# 死锁
## 死锁成因
### 不同表相同记录行锁冲突
事务A和事务B操作两张表，但出现循环等待锁的情况。 事务A在等待表msg中token='asd'的行锁（现在被事务B占有），事务B在等表table_1中id=1的行锁（现在被事务A占有）就这样出现了循环等待

| 事务A                                             | 事务B                                             |
| ------------------------------------------------- | --------------------------------------------------|
| begin                                             | begin                                             |
| delete from table_1 where id = 1                  |                                                   |
|                                                   | update msg set message='订单' where token = 'asd' |
| update msg set message='订单' where token = 'asd' |                                                   |
|                                                   | delete from table_1 where id = 1                  |

### 相同表记录行锁冲突
事务A和事务B操作相同的表，但出现循环等待锁的情况。事务A在等待表table_1中id=2的行锁（现在被事务B占有），事务B在等待表table_1中id=1的行锁（现在被事务B占有）就这样出现了循环等待

| 事务A                                             | 事务B                                              |
| ------------------------------------------------- | -------------------------------------------------- |
| begin                                             | begin                                              |
| update from table_1 where id = 1                  |                                                    |
|                                                   | update from table_1 where id = 2                   |
| update from table_1 where id = 2                  |                                                    |
|                                                   | delete from table_1 where id = 1                   |

## 解决方案
发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个获取锁完成事务
如果没有自动解决还可以手动kill掉死锁的连接，通过`show processlist`找到有问题的连接，然后`kill`这个连接。
