---
title: "线程"
date: 2015-01-13 00:24:41 +0800
categories: java
tags: [thread, java]
---

### 什么是线程？
线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。Java在语言层面对多线程提供了卓越的支持，它也是一个很好的卖点。

### 进程与程序的区别
* 程序是一组指令的集合，它是静态的实体，没有执行的含义。而进程是一个动态的实体，有自己的生命周期。
* 一般说来，一个进程肯定与一个程序相对应，并且只有一个，但是一个程序可以有多个进程，也可以只有一个进程。

### 线程和进程有什么区别？
线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。

### 线程的基本概念、线程的基本状态以及状态之间的关系?
基本概念：

一个程序中可以有多条执行线索同时执行，一个线程就是程序中的一条执行线索，每个线程上都关联有要执行的代码，即可以有多段程序代码同时运行，每个程序至少都有一个线程，即main方法执行的那个线程。如果只是一个cpu，它怎么能够同时执行多段程序呢?这是从宏观上来看的，cpu一会执行a线索，一会执行b线索，切换时间很快，给人的感觉是a，b在同时执行，好比大家在同一个办公室上网，只有一条链接到外部网线，其实，这条网线一会为a传数据，一会为b传数据，由于切换时间很短暂，所以，大家感觉都在同时上网。

基本状态：

就绪，运行，synchronize阻塞，wait和sleep挂起，结束。wait必须在synchronized内部调用。

状态之间的关系：

调用线程的start方法后线程进入就绪状态，线程调度系统将就绪状态的线程转为运行状态，遇到synchronized语句时，由运行状态转为阻塞，当synchronized获得锁后，由阻塞转为运行，在这种情况可以调用wait方法转为挂起状态，当线程关联的代码执行完后，线程变为结束状态。

<!-- more -->
### java中有几种方法可以实现一个线程?用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用?
* 有两种实现方法，分别是继承Thread类与实现Runnable接口
* 用synchronized关键字修饰同步方法
* 反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被"挂起"的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。

### sleep()和wait()有什么区别?
* sleep是线程类Thread的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。
* wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法(或notifyAll)后本线程才进入对象锁定池准备获得对象锁进入运行状态。

### 为什么wait和notify方法要在同步块中调用？
主要是因为Java API强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。还有一个原因是为了避免wait和notify之间产生竞态条件。

### 为什么你应该在循环中检查等待条件?
处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在notify()方法调用之后和等待线程醒来之前这段时间它可能会改变。

### 同步和异步有何异同，在什么情况下分别使用他们?举例说明。
* 如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。
* 当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。

### Thread类中的start()和run()方法有什么区别？[详细](http://javarevisited.blogspot.sg/2012/03/difference-between-start-and-run-method.html)
* start()方法会创建一个新的线程，而且start()方法会在内部调用run方法；直接调用run()方法的话只会在当前线程运行这个方法，而不会新建一个线程。
* start()方法只能调用一次，后面再调用的话会IllegalStateException；可以直接调用run()方法多次。

### Java中Runnable和Callable有什么不同？[详细](http://java67.blogspot.com/2013/01/difference-between-callable-and-runnable-java.html)
* Runnable从JDK1.0开始就有了，Callable是在JDK1.5增加的。
* Runnable的run()方法没有返回值，Callable的call()方法有返回值和Checked Exception。
* Callable可以返回装载有计算结果的Future对象。

### Java内存模型是什么？
Java内存模型规定和指引Java程序在不同的内存架构、CPU和操作系统间有确定性地行为。它在多线程的情况下尤其重要。Java内存模型对一个线程所做的变动能被其它线程可见提供了保证，它们之间是先行发生关系。这个关系定义了一些规则让程序员在并发编程时思路更清晰。比如，先行发生关系确保了：
* 线程内的代码能够按先后顺序执行，这被称为程序次序规则。
* 对于同一个锁，一个解锁操作一定要在时间上发生在另一个锁定操作之前，也叫做线程锁定规则。
* 前一个对volatile的写操作在后一个volatile的读操作之前，也叫volatile变量规则。
* 一个线程内的任何操作必需在这个线程的start()调用之后，也叫作线程启动规则。
* 一个线程的所有操作都会在线程终止之前，线程终止规则。
* 一个对象的终结操作必需在这个对象构造完成之后，也叫对象终结规则。
* 可传递性。如果A在B之前发生，B在C之前发生，则A在C之前发生。

### Java中的volatile 变量是什么？[详细](http://javarevisited.blogspot.com/2011/06/volatile-keyword-java-example-tutorial.html)
volatile是一个特殊的修饰符，只有成员变量才能使用它。在Java并发程序缺少同步类的情况下，多线程对成员变量的操作对其它线程是透明的。volatile变量可以保证下一个读取操作会在前一个写操作之后发生。

### 一个线程运行时发生异常会怎样？
如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理。
### 当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?
分以下几钟情况：

* 其他方法前是否加了synchronized关键字，如果没加，则能。
* 如果这个方法内部调用了wait，则可以进入其他synchronized方法。
* 如果其他个方法都加了synchronized关键字，并且内部没有调用wait，则不能。
* 如果其他方法是static，它用的同步锁是当前类的字节码，与非静态的方法不能同步，因为非静态的方法用的是this。

### 简述synchronized和java.util.concurrent.locks.Lock的异同?
相同点：

* 简述synchronized和java.util.concurrent.locks.Lock的异同?

不同点：
* Lock有比synchronized更精确的线程语义和更好的性能。
* synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。
* Lock还有更强大的功能，例如，它的tryLock方法可以非阻塞方式去拿锁。

### 如果你提交任务时，线程池队列已满。会时发会生什么？
这个问题问得很狡猾，许多程序员会认为该任务会阻塞直到线程池队列有空位。事实上如果一个任务不能被调度执行那么ThreadPoolExecutor’s submit()方法将会抛出一个RejectedExecutionException异常。

### 什么是阻塞式方法？
阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket的accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。

### 多线程中的忙循环是什么?
忙循环就是程序员用循环让一个线程等待，不像传统方法wait(), sleep() 或 yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。

### 如何避免死锁？
死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必须满足以下四个条件：

* 互斥条件：一个资源每次只能被一个进程使用。
* 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
* 不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。
* 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁。

### Java中活锁和死锁有什么区别？
活锁和死锁类似，不同之处在于处于活锁的线程或进程的状态是不断改变的，活锁可以认为是一种特殊的饥饿。一个现实的活锁例子是两个人在狭小的走廊碰到，两个人都试着避让对方好让彼此通过，但是因为避让的方向都一样导致最后谁都不能通过走廊。简单的说就是，活锁和死锁的主要区别是前者进程的状态可以改变但是却不能继续执行。
