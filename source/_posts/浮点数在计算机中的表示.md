title: "浮点数在计算机中的表示"
date: 2015-06-20 21:40:41
categories: os
tags: os
---

# 引入
* 在java中`2.0/0`的结果是`Infinity`，而`2/0`的结果是`java.lang.ArithmeticException: / by zero`，为什么浮点数除以0是无穷大而整数除以0却会报错呢？
* 在Float和Double中可以看到`POSITIVE_INFINITY`, `NEGATIVE_INFINITY`, `NaN`这几个常量，而在Integer和Long中却没有，这又是为什么呢？
* 浮点数中有+0.0和-0.0的表示，但整数只有0，这又是为什么呢？

如果你了解浮点数在计算机是是怎么表示的话，就会明白出现上面2种情况的原因了

# 浮点数在计算机中的表示
根据国际标准IEEE 754，任意一个二进制浮点数V可以表示成下面的形式:

$$V = (-1)^s \times M \times 2^E$$

* $(-1)^s$表示符号位，当s=0时，V为正数；当s=1时，V为负数。
* M表示有效位数，1 <= M < 2
* $2^E$表示指数位

如：

* 十进制的5.0，写成二进制是101.0，可以表示成$1.01 \times 2^2$。按照上面V的公式可以得出：s=0, M=1.01, E=2
* 十进制的-5.0，写成二进制是-101.0，可以表示成$-1 \times 1.01 \times 2^2$按照上面V的公式可以得出：s=1， M=1.01, E=2

IEEE 754规定，对于32位的浮点数，最高的1位是符号位s，接着的8位是指数E，剩下的23位为有效数字M；
对于64位的浮点数，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M，如下图：
![standard-floating-point-formats](/images/standard-floating-point-formats.jpg)

<!-- more -->
# E, M的具体规则
## M的规则
1 <= M < 2, 也就是说M可以写成1.xxxxxx的形式，其中xxxxxx表示小数部分。IEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分。比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的，是节省1位有效数字。以32位浮点数为例，留给M只有23位，将第一位的1舍去以后，等于可以保存24位有效数字。

## E的规则
首先，E是一个无符号整数。也就是说，如果E是8位，它的取值范围是0~255；如果是11位，它的取值范围是0~2047。但是，我们知道，科学计数法中的E是可以出现负数的，所以IEEE 754规定，E的真实值必须再减去一个中间数($2^{k-1} - 1$, k表示E的二进制位数)，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。

比如，$2^{10}$的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001。

根据指数E的情况，浮点数表示有三种不同情况：

![categories-of-single-precision-floating-point-values](/images/categories-of-single-precision-floating-point-values.jpg)

* E不全为0或不全为1。这时，浮点数就采用上面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第一位的1。
* E全为0。这时，浮点数的指数E等于1-127（或者1-1023），有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。
* E全为1。这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）；如果有效数字M不全为0，表示这个数不是一个数（NaN）。

如下图表示了8位的浮点数(其中M的位数是3，E的位数是4):
![nonnegative-values-for-8-bit-floating-point-format](/images/nonnegative-values-for-8-bit-floating-point-format.jpg)


